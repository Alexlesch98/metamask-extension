diff --git a/dist/NftController.js b/dist/NftController.js
index ecbb338b3d52f0c9f40ccc81f5a50c8c41b542f0..7056db263301fcf0527606dfe6c2c1d3240edc8a 100644
--- a/dist/NftController.js
+++ b/dist/NftController.js
@@ -778,6 +778,32 @@ class NftController extends base_controller_1.BaseControllerV1 {
             }
         });
     }
+    /**
+     * Refetches NFT metadata and updates the state
+     *
+     * @param options - Options for refetching NFT metadata
+     * @param options.nfts - Array of nfts
+     * @param options.networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param options.userAddress - The current user address
+     */
+    updateNftMetadata({ nfts, networkClientId, userAddress = this.config.selectedAddress, }) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const chainId = this.getCorrectChainId({ networkClientId });
+            const nftsWithChecksumAdr = nfts.map((nft) => {
+                return Object.assign(Object.assign({}, nft), { address: (0, controller_utils_1.toChecksumHexAddress)(nft.address) });
+            });
+            const nftMetadataResults = yield Promise.allSettled(nftsWithChecksumAdr.map((nft) => __awaiter(this, void 0, void 0, function* () {
+                const resMetadata = yield this.getNftInformation(nft.address, nft.tokenId, networkClientId);
+                return {
+                    nft,
+                    newMetadata: resMetadata,
+                };
+            })));
+            nftMetadataResults
+                .filter((result) => result.status === 'fulfilled')
+                .forEach((elm) => this.updateNft(elm.value.nft, elm.value.newMetadata, userAddress, chainId));
+        });
+    }
     /**
      * Removes an NFT from the stored token list.
      *

diff --git a/dist/NftController.js b/dist/NftController.js
index ecbb338b3d52f0c9f40ccc81f5a50c8c41b542f0..eaeaa7df10d369cb01c03f16c061ade4e83968ec 100644
--- a/dist/NftController.js
+++ b/dist/NftController.js
@@ -778,6 +778,33 @@ class NftController extends base_controller_1.BaseControllerV1 {
             }
         });
     }
+    /**
+     * Refetches NFT metadata and updates the state.
+     *
+     * @param nfts - Array of nfts
+     * @param networkClientId - The networkClientId that can be used to identify the network client to use for this request.
+     * @param userAddress - The current user address
+     */
+    updateNftMetadata(nfts, networkClientId, userAddress = this.config.selectedAddress) {
+        return __awaiter(this, void 0, void 0, function* () {
+            const chainId = this.getCorrectChainId({ networkClientId });
+            const nftsWithChecksumAdr = nfts.map((nft) => {
+                return Object.assign(Object.assign({}, nft), { address: (0, controller_utils_1.toChecksumHexAddress)(nft.address) });
+            });
+            const nftMetadataResults = yield Promise.allSettled(nftsWithChecksumAdr.map((nft) => __awaiter(this, void 0, void 0, function* () {
+                const resMetadata = yield this.getNftInformation(nft.address, nft.tokenId, networkClientId);
+                return {
+                    nft,
+                    newMetadata: resMetadata,
+                };
+            })));
+            // lib.es2020.promise.d.ts does not export its types so we're using a simple type.
+            const success = nftMetadataResults.filter((promise) => promise.status === 'fulfilled');
+            if (success.length !== 0) {
+                success.map((elm) => this.updateNft(elm.value.nft, elm.value.newMetadata, userAddress, chainId));
+            }
+        });
+    }
     /**
      * Removes an NFT from the stored token list.
      *
